package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.32

import (
	"context"
	"fmt"

	"github.com/niuee/hrGraphql/dbHandle"
	"github.com/niuee/hrGraphql/graph/model"
)

// Sire is the resolver for the sire field.
func (r *horseResolver) Sire(ctx context.Context, obj *model.Horse) (*model.Horse, error) {
	db := dbHandle.GetDBConn()
	sqlStatement := `SELECT horse_name, alt_name, gender, sire_id, dam_id FROM horses WHERE id=$1;`
	var horse = model.Horse{}
	var returnErr error = nil
	row := db.QueryRow(sqlStatement, obj.SireID)
	returnErr = row.Scan(&horse.Name, &horse.AltName, &horse.Gender, &horse.SireID, &horse.DamID)
	if obj.SireID != nil {
		horse.ID = *obj.SireID
	}
	return &horse, returnErr
}

// Dam is the resolver for the dam field.
func (r *horseResolver) Dam(ctx context.Context, obj *model.Horse) (*model.Horse, error) {
	db := dbHandle.GetDBConn()
	sqlStatement := `SELECT horse_name, alt_name, gender, sire_id, dam_id FROM horses WHERE id=$1;`
	var horse = model.Horse{}
	var returnErr error = nil
	row := db.QueryRow(sqlStatement, obj.DamID)
	returnErr = row.Scan(&horse.Name, &horse.AltName, &horse.Gender, &horse.SireID, &horse.DamID)
	if obj.DamID != nil {
		horse.ID = *obj.DamID
	}
	return &horse, returnErr
}

// Test is the resolver for the test field.
func (r *mutationResolver) Test(ctx context.Context, input *string) (*model.Horse, error) {
	panic(fmt.Errorf("not implemented: Test - test"))
}

// Horse is the resolver for the horse field.
func (r *queryResolver) Horse(ctx context.Context, horseID *string, horseName *string) (*model.Horse, error) {
	db := dbHandle.GetDBConn()
	var returnErr error = nil
	if horseID != nil {
		sqlStatement := `SELECT horse_name, alt_name, gender, sire_id, dam_id FROM horses WHERE id=$1;`
		var horse = model.Horse{}
		horse.ID = *horseID
		row := db.QueryRow(sqlStatement, horseID)
		returnErr = row.Scan(&horse.Name, &horse.AltName, &horse.Gender, &horse.SireID, &horse.DamID)
		return &horse, returnErr
	}
	if horseName != nil {
		sqlStatement := `SELECT horse_name, alt_name, gender, sire_id, dam_id FROM horses WHERE horse_name=$1 or alt_name=$1;`
		var horse = model.Horse{}
		horse.Name = *horseName
		row := db.QueryRow(sqlStatement, horseName)
		returnErr = row.Scan(&horse.Name, &horse.AltName, &horse.Gender, &horse.SireID, &horse.DamID)
		return &horse, returnErr
	}

	sqlStatement := `SELECT horse_name, alt_name, gender, sire_id, dam_id FROM horses ORDER BY id ASC LIMIT 1;`
	var horse = model.Horse{}
	row := db.QueryRow(sqlStatement)
	returnErr = row.Scan(&horse.Name, &horse.AltName, &horse.Gender, &horse.SireID, &horse.DamID)
	return &horse, returnErr
}

// Horse returns HorseResolver implementation.
func (r *Resolver) Horse() HorseResolver { return &horseResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type horseResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
